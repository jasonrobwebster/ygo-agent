# Appendix: `YGOProEnv` to `YgoCoreAdapter` Refactor Plan

This document serves as a detailed, function-level guide for refactoring the `YGOProEnv` class into a thin wrapper around a new `YgoCoreAdapter` class. The goal is to isolate all direct interactions with the `ygopro-core` C-API into the adapter, leaving `YGOProEnv` to manage environment-level concerns like state, rewards, and player interaction.

---

## 1. Helper Functions & Data Structures

These are standalone utilities currently within `ygopro.h`. They are not directly part of the `YGOProEnv` class but are used by it.

**Action:** Move these to a new, shared header file, e.g., `ygoenv/ygopro/utils.h`, so both the adapter and the environment can access them if needed.

| Function/Struct | Current Location | Target Location | Notes |
| :--- | :--- | :--- | :--- |
| `combinations()` | `ygopro.h` | `utils.h` | General-purpose combination utility. |
| `sum_to()` | `ygopro.h` | `utils.h` | Helper for `combinations_with_weight`. |
| `combinations_with_weight()` | `ygopro.h` | `utils.h` | Used for MSG_SELECT_SUM. |
| `msg_to_string()` | `ygopro.h` | `utils.h` | Debugging utility. |
| `ls_to_spec()`, `spec_to_ls()` | `ygopro.h` | `utils.h` | Location/spec string conversion. |
| `read_decks()` | `ygopro.h` | `utils.h` | Deck reading utility. |
| `LegalAction` struct | `ygopro.h` | `ygo_data_types.h` | Becomes a core data structure. |
| `Card` class | `ygopro.h` | `ygo_data_types.h` | Becomes a core data structure. |
| `init_module()` | `ygopro.h` | `YgoCoreAdapter` | Becomes a static method on the adapter to initialize shared resources. |

---

## 2. Member Variables

The member variables of `YGOProEnv` will be split. The adapter will own everything related to the core duel engine, while the environment will retain variables related to the Gym/EnvPool interface.

| `YGOProEnv` Member | To `YgoCoreAdapter`? | Notes |
| :--- | :--- | :--- |
| `pduel_` | **Yes** | **Central change.** The adapter will create, own, and destroy `pduel`. |
| `buf_` | **Yes** | The buffer for receiving messages from `YGO_GetMessage`. |
| `data_` | **Yes** | The `byte*` pointer to `buf_`. |
| `dp_` | **Yes** | Data pointer for reading `buf_`. |
| `qbuf_` | **Yes** | Buffer for query results. |
| `spec_` | No | Belongs to the EnvPool environment. |
| `done_` | No | Environment state. |
| `reward_` | No | Environment state. |
| `turn_` | **Yes** | The core engine tracks the turn. |
| `player_` | No | Player object (e.g., RandomAI, HumanPlayer). |
| `legal_actions_` | No | Actions are an environment-level concept. |
| `replay_` | **Yes** | Replay buffer and logic should live with the duel instance. |
| `m_deck_`, `e_deck_` | **Yes** | The duel engine needs to know the decks to start. |

---

## 3. Core C-API Wrappers

These are the lowest-level private methods in `YGOProEnv` that call the C-API.

**Action:** These will be moved directly to `YgoCoreAdapter` and will likely become `private` methods there, called by the adapter's public interface.

| `YGOProEnv` Method | Target `YgoCoreAdapter` Method | `YGOProEnv`'s New Implementation |
| :--- | :--- | :--- |
| `YGO_CreateDuel()` | `YgoCoreAdapter::YgoCoreAdapter(seed)` (Constructor) | `adapter_ = std::make_unique<YgoCoreAdapter>(seed);` |
| `YGO_EndDuel()` | `YgoCoreAdapter::~YgoCoreAdapter()` (Destructor) | `adapter_.reset();` |
| `YGO_SetPlayerInfo()` | `void set_player_info(...)` | `adapter_->set_player_info(...);` |
| `YGO_NewCard()` | `void add_card(...)` | `adapter_->add_card(...);` |
| `YGO_StartDuel()` | `void start_duel(...)` | `adapter_->start_duel(...);` |
| `YGO_Process()` | `uint32_t process()` | `adapter_->process();` |
| `YGO_GetMessage()` | `int32_t get_message(byte* buf)` | `adapter_->get_message(buf);` |
| `YGO_QueryCard()` | `CardInfo query_card(...)` | `adapter_->query_card(...);` |
| `YGO_QueryFieldCount()`| `int32_t query_field_count(...)` | `adapter_->query_field_count(...);` |
| `YGO_QueryFieldCard()`| `std::vector<CardInfo> query_field_card(...)` | `adapter_->query_field_card(...);` |
| `YGO_SetResponsei()` | `void set_response(int32_t value)` | `adapter_->set_response(value);` |
| `YGO_SetResponseb()` | `void set_response(const std::vector<byte>& buf)` | `adapter_->set_response(buf);` |

---

## 4. Game State and Logic Functions

These methods in `YGOProEnv` manage the duel's lifecycle and state transitions.

| `YGOProEnv` Method | Target `YgoCoreAdapter` Public Method | `YGOProEnv`'s New Implementation |
| :--- | :--- | :--- |
| `new_duel(seed)` | `(Constructor)` | Initializes the adapter. |
| `reset()` | `void reset()` (if needed) or handled by new duel creation. | Calls `adapter_.reset()` and creates a new one. |
| `next()` | `void step_duel()` (or similar name) | Delegates the entire function body to `adapter_->step_duel()` and then populates `legal_actions_`. |
| `get_card_code()` | `CardCode get_card_code(...)` | `return adapter_->get_card_code(...);` |
| `get_card()` | `Card get_card(...)` | `return adapter_->get_card(...);` |
| `read_u8()`, `read_u16()`, `read_u32()` | Becomes private methods in `YgoCoreAdapter`. | No longer exists in `YGOProEnv`. |
| `q_read_u8()`, `q_read_u32()` | Becomes private methods in `YgoCoreAdapter`. | No longer exists in `YGOProEnv`. |

---

## 5. Message Handling & Action Generation

This is the most complex part of `YGOProEnv`. The `handle_message()` function is a giant `switch` statement that parses duel engine messages and populates `legal_actions_`.

**Action:** The entire `handle_message()` method and its many helpers (`read_cardlist_spec`, etc.) will move into `YgoCoreAdapter`. The adapter will expose a single, high-level method to get the results.

| `YGOProEnv` Method | Target `YgoCoreAdapter` Public Method | `YGOProEnv`'s New Implementation |
| :--- | :--- | :--- |
| `handle_message()` | `std::vector<LegalAction> process_messages()` | `legal_actions_ = adapter_->process_messages();` |
| `read_cardlist_spec()` | Becomes a private helper in `YgoCoreAdapter`. | No longer exists. |
| `get_actions_for_battle_cmd()` | Becomes a private helper in `YgoCoreAdapter`. | No longer exists. |
| `get_actions_for_idle_cmd()` | Becomes a private helper in `YgoCoreAdapter`. | No longer exists. |
| `get_actions_for_select_chain()`| Becomes a private helper in `YgoCoreAdapter`. | No longer exists. |
| ... (and all other sub-handlers for messages) | All become private helpers within `YgoCoreAdapter`. | No longer exist. |

The `YgoCoreAdapter` will internally call `YGO_Process()`, loop through `YGO_GetMessage()`, and run the `handle_message()` logic. It will return a fully populated `std::vector<LegalAction>` to `YGOProEnv`.

---

## 6. Observation & State Serialization (`WriteState`)

The `WriteState` method is responsible for serializing the game state into the `State` object for the Python layer. It uses many helper methods (`_set_obs_*`) to do this.

**Action:** This logic will **remain in `YGOProEnv`**. However, instead of calling C-API query functions directly, it will call the new, clean query methods on the adapter.

| `YGOProEnv` Method | New Implementation Detail |
| :--- | :--- |
| `WriteState(State& state)` | The overall structure remains. |
| `_set_obs_global()` | Calls `adapter_->query_field_count()` and other global state queries. |
| `_set_obs_mask_()` | Calls `adapter_->query_field_card()` to get card data, then writes to the observation tensor. |
| `_set_obs_actions()` | Iterates through the `legal_actions_` vector (which was generated by the adapter). |
| `spec_to_card_id()` | Remains in `YGOProEnv` but uses `adapter_->query_card()` to find card details if needed. |
| All other `_set_obs_*` helpers | Remain in `YGOProEnv` and operate on the data structures returned by the adapter. |

This division of responsibility ensures the adapter is purely concerned with running the duel and understanding its state, while the environment is responsible for translating that state into the specific tensor format required by the learning algorithm. 